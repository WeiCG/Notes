# 继承映射

> ORM对象模型是使用面向对象思想操作数据库，这其中面向对象两大特性继承和多态是一定绕不过的

## 所有类映射一张表

- 这种方式是Hibernate默认的映射方式
- 包括父类和子类的所有实例全部都存储到一张表中
- **优点 - 只在一个表中增删改查，所以性能最好**
- **缺点 - 所有子类的字段不能有非空约束，因为父类中没有该字段**

### DiscriminatorColumn

- 作用: 由于所有实例全部存储于一张表中，因此**在根父类中使用该注解，为数据表额外增加一列来区分实例**

|       属性        |                      说明                       | 默认值  |
| :---------------: | :---------------------------------------------: | :-----: |
|       name        |                  指定列的名称                   | "DTYPE" |
| discriminatorType | 指定该类的数据类型，值为DiscriminatorType枚举类 | STRING  |

| DiscriminatorType取值 | 说明       |
| :-------------------: | ---------- |
|        STRING         | 字符串类型 |
|        INTEGER        | 整数类型   |
|         CHAR          | 字符类型   |

### DiscriminateValue

- 作用: 在父类和所有子类中增加该注解，来指定对应类在区分列上的值

| 属性  |              说明              | 默认值 |
| :---: | :----------------------------: | :----: |
| value | 指定不同持久化类在区分列上的值 |   无   |

---

## 连接子类映射

- 父类数据保存到父类中，子类数据则由父类表和子类表共同存储

- 父类和子类共有的属性保存到父类表中，子类额外增加的字段保存在子类表中

- 所有的子类表中都存在父类的主键，这同时也是子类表的主键，这是维护继承关系的核心，也是查询对应数据的关键

- 优点

    1. 配置简单，只需在根父类中使用Inheritance注解即可

    2. 无需增加额外的区分列，同时子类属性也可以有非空约束

- 缺点 - 需要多表查询，对于类继承层次较深的继承来说，性能比较底下

### Inheritance

- 作用: 该映射不是Hibernate默认的映射，所以使用该注解配置Hibernate的继承映射策略

|   属性   |                  说明                   |    默认值    |
| :------: | :-------------------------------------: | :----------: |
| strategy | 配置映射策略，值是InheritanceType枚举类 | SINGLE_TABLE |

| InheritanceType取值 | 说明                             |
| :-----------------: | -------------------------------- |
|    SINGLE_TABLE     | 所有类映射一张表的映射策略       |
|       JOINED        | 连接子类的映射策略               |
|   TABLE_RER_CLASS   | 每个持久化类映射一张表的映射策略 |

---

## 每个类映射一个表

- 父类数据保存到父类表中，子类数据仅保存到子类表中
- 这种映射策略很难看出表的继承关系，为了维护表中的继承关系，需要我们自己来生成主键值，因此只能使用TABLE的主键生成策略，详见Hibernate（三）
- 同时，这种映射与连接子类映射相同，都**需要配置Inheritance注解**
- 优点 - 容易理解，符合数据库设计
- 缺点
    1. 几乎无法看出类之间的继承关系
    2. 难以生成高效的SQL语句，性能低下 