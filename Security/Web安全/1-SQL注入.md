# SQL注入

> 2020年11月12日 奔跑的咸鱼

## 概念

**定义：**SQL注入是服务端未严格校验客户端发送的数据，而导致服务端SQL语句被恶意修改并成功执行的行为

**原因：**

1. 代码对带入SQL语句的参数过滤不严格
2. 未启用框架的安全配置
3. 未使用框架提供的安全查询方法
4. 测试接口未删除
5. 未启用防火墙
6. 未使用其他的安全防护设备

**适用场景：**所有涉及到与数据库交互的情景都可能发生SQL注入

**分类：**

- 按照请求方法分类
  - **GET注入：**SQL语句需要URL中的参数来构建
  - **POST注入：**SQL语句需要网页中的部分用户输入来构建
  
- 按照SQL数据类型分类
  - **整型注入：**要输入的数据是整型的
  - **字符型注入：**要输入的数据是字符型的，因此必须要闭合字符串才行。闭合的东西包括单引号、双引号和括号
  
- 其他的数据类型
  - **报错注入：**根据页面显示的错误信息来分析如何注入。报错注入的一个关键点是当数据库查询发生错误时，它会将错误语句直接显示到页码中，但如果数据库语句正确执行后，之后显示其执行的是否正确，无法通过构造`union`语句实现获取信息。因此大部分情况下是通过在`union`语句中手动构建错误，来从错误中获取需要的信息。通常使用`extractvalue(1, concat(0x7e, SQL语句))`函数，其中`0x7e`是用来确保SQL语句返回的结果不会因为其他符号而被截断，同时`0x7e`也保证不会被安全函数过滤掉。
  
  - **双注入：**双注入和报错注入的情况基本相同，但其不使用`extractvalue()`函数来构建错误，而是在`union select`语句中再构建一个`select`语句 ，通过第二个`select`语句报错的错误来进行注入
  
    例子：`xxx union select 1, count(1) from information_schema.tables group by concat(floor(rand()*2), (select table_name from information_schema.tables where table_scheam='xxx' limit 0,1))`，这里要注意如果例子中的`concat`函数的字符串过长，可能会导致数据库直接忽略，最好使用`limit`这种限制长度的语句来一次次查找
  
  - **Cookie注入和HTTP-Referen注入**：SQL语句的构建中需要获取Cookie或User-Agent等HTTP协议头来辅助，因此通过修改HTTP协议头来进行注入
  
- 盲注

  看不见的注入，即看不见数据库的报错、看不见页面的错误，只能通过页面的变化来处理，是一种相当高级的攻击手法

  - 布尔盲注：对于不同的输入，页面会显示不同的内容，根据内容的变化来进行注入
  
    例子：`id=1' and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema=database() limit 0,1)=97`，根据例子判断表名的第一个字母是否是a
  
  - 时间盲注：比布尔盲注更加困难，对于不同的输入，页面中显示的内容是相同的，通过在SQL语句中配置`sleep()`函数来延迟SQL语句执行的时间，并依次影响页面的显示时间来进行注入
  
    例子：`id=1' and if((select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema=database() limit 0,1)=97, sleep(2),0)`，根据例子如果表名的第一个字符为a则页面延迟加载2秒
  
- 文件读取

  文件读取是一种比较高级的注入方式，同时也是一种破坏性较大的注入方法，可以直接读取程序源码或重要的配置文件

  使用`load_file(file_name)`函数来读取文件并返回该文件的内容作为一个字符串，需要有如下的前提。对于读取出的文件内容，最好使用`hex()`函数将其转换为十六进制，然后在转换为字符串。

  1. 必须拥有读取文件的权限并且文件可读
  2. 欲读取的文件在服务器上
  3. 必须指定文件的完整路径
  4. 文件大小必须小于`max_allowed_packet`配置

  使用`into outfile "xxx”`语法来将语句写入服务器的文件中。例子：`id=1' union select 1,2,3 into outfile "/var/www/html/sqli-lab/a.txt"`，根据例子将查询出的内容和1 2 3写入a.txt中，可以写入PHP代码使其成为php文件然后调用。

  1. 必须要有写入权限

  

## 步骤

### 判断是否有注入

1. 是否对用户输入进行了严格校验 - 首要条件
   - 可控参数的不同输入能否影响页面的改变
   - 输入的SQL语句是否能报错，即根据显示的数据库错误信息来查看数据库语句的一些痕迹
   - 输入的SQL语句是否能不报错

2. 判断什么类型的注入

3. 语句是否可以被恶意修改

4. 修改后语句是否可以成功执行

### 获取需要的信息

如果要获取信息，必须要详细了解数据库和SQL语句

如果在攻击中要一次查询两张表，必须使用`union`语句，该语句会返回一张表。但`union`语句要保证前后两个的查询结果必须类型和数目完全一致，因此首先要判断正常的服务端SQL语句的查询出的类型和数目

1. 直接通过`union select 1,2,3,…`测试，直到其显示正常
2. 通过`order by 列名或对应的列数`测试，如果列名不存在或列数大于查询出的列会直接报错

**注意**：如果需要注释SQL语句后面的内容时，最好使用`%23`而不是`#`，同时，使用`and`而不是`or`

## 绕过技巧

#### MySQL

MySQL的数据库、表和字段信息都存储在information_schema数据库中

| 字段                                  |    表    |                    描述                    |
| :------------------------------------ | :------: | :----------------------------------------: |
| schema_name                           | schemata |              所有数据库的名称              |
| table_name、table_schema              |  tables  |    数据库中所有的表名称及其所在的数据库    |
| column_name、table_name、table_schema | columns  | 数据库中所有的字段名称及其所在的数据库和表 |

函数小技巧

|     函数名     | 描述                                                         |
| :------------: | ------------------------------------------------------------ |
| group_concat() | 将指定列的所有值拼接为一个字符串返回，用于一次查询指定列的所有返回结果 |
|     user()     | 查看当前登陆用户                                             |
|   version()    | 查看当前MySQL的版本                                          |
|   database()   | 当前所在数据库                                               |
|  concat_ws()   | 拼接字段返回字符串。参数1是分隔符，后面的参数是要拼接的字段  |
| extractvalue() | 从目标XML中返回包含所查询值的字符串。第一个参数是要查询的字符串，第二个是XPath语法，通过输入错误的XPath语法，使用报错注入来获取相关的信息 |
|                |                                                              |
|                |                                                              |
|                |                                                              |

