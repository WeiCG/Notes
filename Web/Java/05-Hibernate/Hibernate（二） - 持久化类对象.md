# 持久化类对象

> Hibernate中将定义的类分为了两类，一类是与数据库表相对应的实体类，被称为持久化类；另一类则单纯的被看作值类型，被称为组件类。对于持久化类对象的理解是使用Hibernate开发程序的第一步

## 持久化类的要求

Hibernate对于持久化类基本没有太多的要求，但还是建议遵守如下规律

1. 类的设计遵从JavaBean规范，即首先应该是一个实体类
   * 类应该是一个公共类
   * 必须有一个公共的无参构造函数
   * 不应该有公共的属性，属性都为private
   * 为私有属性提供相应的get/set方法
   * 实现Serializeable接口
2. 要有唯一的标识属性
3. 使用非final类
4. **属性建议使用基本数据类型对应的包装类**
5. **重写equals和hashCode方法**

---

## 持久化类的三种状态

### 瞬时态

* 识别方法
  * 对象在数据库中没有对应的记录，即对象中没有对应的标识属性
  * 对象与Session对象没有关联
* **在程序中创建的持久化类对象，但并没有存入数据库中，在程序结束运行或长时间未被引用后便会被GC销毁**

```Java
// User对象在数据库中没有对应的唯一标识属性，且尚未与Session对象关联
// user对象是瞬时态对象
User user = new User();
user.setUsername("xxx");
user.setPassword("123");
```

### 持久态

* 识别方法
  * 对象在数据库有对应的记录
  * 对象与Session对象有关联
* **在数据库中有对应的记录，且在程序使用的过程中，该对象一直都与数据库有关联，因此我们对持久态对象所做的一切修改都会被同步到数据库中去**

```Java
// user中有id值，而且是由Session对象查询出
User user = session.get(User.class, 1);
```

### 托管态

* 识别方法
  * 对象在数据库有对应的记录
  * 对象与Session对象没有关联
* **持久态对象由于程序关闭了对象与数据库之间的联系，从而转换为了托管态对象。但该对象仍可以在程序中被使用**

```Java
// 从数据库中取出持久态对象user
User user = session.get(User.class, 1);
// 关闭Session对象
session.close();
// 继续操作user对象，此时的user对象便是托管态对象
user.setName("haha");
```

---

## 持久化类三种状态之间的转化

三种对象的转化共有四种情况，不会出现持久态转瞬时态、托管态转瞬时态

### 瞬时态对象到持久态对象

* **使用Session对象中的save/persist方法**
* 相同点
  * 将一个对象由瞬时态对象变为持久态对象
  * Hibernate会在底层生成一条insert语句来执行操作

* 不同点 - 使用时建议使用**persist**

区别 | save | persist
:--: | :--: | :--:
返回值 | 当前保存对象的**标识属性值**，即数据库表中默认生成的主键值 | 无
执行情况 | 由于会返回标识属性，所以不论是否在事务中，调用save方法都会立即生成insert语句 | 如果在一个事务外部调用persist方式，则不会立即生成insert语句
JPA | 不是JPA标准 | 是JPA标准 

### 瞬时态对象到托管态对象

* 可以显式为瞬时态对象的标识属性赋值，主动将瞬时态对象与数据库中的某个记录对应，但**这种转换没有任何意义，而且极度不推荐**

### 持久态对象到托管态对象

* **关闭持久态对象对应的Session连接即可**

### 托管态对象到持久态对象

* **使用Session对象中的update/merge/saveOrUpdate方法**
* 相同点
  * 若转换前对托管态对象进行过修改，则转换后所有修改都会同步到数据库中（**注意: 这里的修改不包括对标识属性值的修改，如果修改了标识属性值则Hibernate不会做任何修改**）
* 不同点 - 推荐使用**merge**

区别 | update | merge
:--:|:--:|:--:
返回值 | 无 | 返回当前托管态对象的副本
是否将当前对象转换为持久态对象 | 是 | 否，但该方法返回的副本为持久态对象
JPA | 不是JPA规范 | 是JPA规范 

---

## 对持久化类的操作

### 添加

* 添加操作实质上是指将瞬时态对象转化为持久态对象的过程
* **注意: 不应该对托管态对象和持久态对象执行添加操作**

### 删除

* **删除操作使用的EntityManager对象的remove方法，该方法需要传入一个持久态对象**

### 修改

* 对于持久态对象来说，由于其与数据库一直保持有联系，所有不需要我们显式保存，Hibernate会默认执行保存操作
* 而对于托管态对象来说，对该对象所有的修改都需要重新将该对象转化为持久态对象才会同步到数据库中，即执行EntityManager对象中的merge方法
* **注意: 不应该对瞬时态对象执行修改操作**

### 查询

* **查询实质上是获取一个持久态对象的过程**
* 使用EntityManager对象中的find/getReference方法，find和getReference方法的主要区别在于是否延迟加载
  * find方法在查询时会立即访问数据库
  * getReference方法只有在调用持久态对象中的属性或方法时才会真正访问数据库
