> 2020年11月12日 奔跑的咸鱼

[安全客文章1](https://www.anquanke.com/post/id/205376)

[郁离歌的博客](http://yulige.top/)

[SQL盲注的效率分析](https://xz.aliyun.com/t/7575)

# 概述

定义：SQL注入是服务端未严格校验客户端发送的数据，而导致服务端SQL语句被恶意修改并成功执行的行为

情景

1. 参数用户可控 - 前端传给后端的参数内容是用户可以控制的
2. 参数带入数据库查询 - 传入的参数拼接到SQL语句，且带入数据库查询

适用场景：所有涉及到与数据库交互的情景都可能发生SQL注入

解决方法：<font color="red">凡外部输入皆不可信</font>

## 分类

- 按注入数据的来源分类
  - GET注入 - SQL语句需要URL中的参数来构建
  - POST注入 - SQL语句需要网页中的部分用户输入来构建
  - HTTP头 - SQL语句需要获取Cookie或User-Agent等HTTP协议头来辅助，因此通过修改HTTP协议头来进行注入
  - JSON类型 - SQL语句需要获取前端传输的JSON格式的数据来构建
- 按注入数据的类型分类
  - 整型注入 - 要输入的数据是整型的
  - 字符型注入 - 要输入的数据是字符型的，因此必须要闭合字符串才行。闭合的东西包括单引号、双引号和括号
  
- 按照注入的方式分类
  - 联合查询注入
  - 报错型注入
  - 布尔型注入
  - 多语句查询注入
  - 二次查询

# 步骤

1. 是否对用户输入进行了严格校验，即可控参数的不同输入能否影响页面的改变

   - 真假判断 - 输入`and 1 = 1`和`and 1 = 2`时，回显页面不同
- 引号判断 - 根据输入单引号或双引号显示数据库错误信息或者页面回显不同
   - 转义判断 - 添加转义符`\`
   - 整型判断 - 对整型参数进行加减1判断其是否会显示对应的前后页
   - 判断页面返回时间 - `and sleep(5)`之类
2. 判断是什么类型的注入
3. 语句是否可以被恶意修改
4. 修改后语句是否可以被成功执行

# 攻击方式

## 概述

不论是什么样的注入方式，都需要获取信息：

- 操作系统、数据库用户和数据库版本
- 所在数据库名、其中的表名和字段名
- 数据库中的具体数据
  - 如果无法获得高权限，则只能够进行常规的数据查询
  - 如果有高权限的话，除数据查询外，还可以**执行命令**和**文件读写**

大部分数据库的注入流程都是一样的，唯一的区别只在于语句的不同，下面的所有攻击方式全部都以MySQL数据库为例

## 简单注入

- 闭合单引号
  - 常见的闭合注释符号: %23\—+\;%00\反引号等
  - 如果单引号或闭合注释符号被ban，通常可以利用`\`来将SQL语句中的单引号转义掉，在想办法注释掉后面的SQL语句

## Union注入

当数据库中有数据返回并显示到前端时，可以通过构建Union注入的手段来使得SQL语句返回数据库中的内容

1. 首先通过`order by`语句来测试select语句中的查询字段数
2. 配合Union语句来确定select语句中输出的是什么位置的查询字段数
3. 使用Union语句来查询相关的数据库、表和字段信息
4. 通过查询到的数据库、表和字段信息来查询具体的数据
   - 使用limit语法依次获取多行数据
   - 使用group_concat()函数显示全部列数据

## Boolean注入

获取的数据不回显至前端页面，但页面会根据数据库中查询出的不同内容显示不同的结果，因此需要构造SQL判断语句，通过查看不同的页面返回结果来推测哪些SQL语句判断条件是成立的

1. 闭合，找到永真和永假的情况
2. 使用`length()`函数与数字进行比较获得要获取名称的长度
3. 在得到长度的前提下，通过`substr()`函数和`ascii()`函数来不断与字母相比较获得实际的名称
   - 例子：`id = 1' and (ascii(substr(database(), 1, 1)) > 1) --+`
4. 不断重复1和2步骤知道获得所有要获取的数据为止

## 时间注入

一种特殊的Boolean注入，当页面根据数据库中查询出的不同内容显示相同的结果，此时，可以利用时间差来进行Boolean注入

时间短为假，时间长为真

利用MySQL的if函数，`if(条件, 1, sleep(要睡眠的秒数))`，当条件为真时，直接返回，当条件为假时，睡眠指定秒数后返回

常见操作

- 直接睡眠`sleep()` - 但很容易被ban
- 大量重复操作`benchmark(次数，要执行的操作)` - 通常是计算某个数的md5值，然后执行上千万次
- 笛卡尔积 - 让数据库生成笛卡尔积，需要数据库的大量时间
  - `if(1, 1, (select count(*) from information_schema.tables A, information_schema.columns B))`

## 报错注入

当查询失败时，系统会直接将数据库的错误信息输出到前端页面，因此可以利用这些错误信息获取数据

注意：MySQL的报错注入通常有长度限制，不要将错误显示超过30个字符

MySQL报错通常就是利用XPath路径解析错误，当XPath路径解析错误时，MySQL会默认输出当前的报错信息

- `updataxml('文档', 'XPath路径', '更新的内容')`，例如，直接写入`updatexml(0x0a, concat(0x0a, database()), 1)`，很明显0x0a和database()拼接成的字符串是XPath解析错误，因此会直接输出0x0a和database()的拼接结果
- `extractvalue('文档', 'XPath路径')`

## 堆叠注入

本质是一次执行多条SQL语句

直接使用结束符号断掉前面的SQL语句，然后注释掉后面的SQL语句

## 二次注入

二次注入的本质是通过两个页面搭配组合进行注入攻击

## 文件读写攻击

文件读写攻击通常需要获取数据库的高权限，并且数据库需要打开文件读写功能才可以实行

MySQL读文件通常使用`load_file()`函数，而写文件则使用两个特殊语法

- `select XXX into outfile '绝对路径’` - 该方法会在行末端写入一个新行，所以如果利用mysql写一些dll或二进制文件，可能会破坏文件
- `select XXX into dumpfile '绝对路径’` - 能够导出一个完整的二进制文件，最好用这个

MySQL写文件时，文件必须要不存在

### 路径获取方法

- 报错显示
- 遗留文件
- 漏洞报错
- 平台配置文件
- 爆破

# 常见数据库

## Access

- 通常是搭配ASP使用，在国内基本没有商业使用的环境，仅限于自己的测试
- Access数据库与其他数据库相比，极其轻量级，Access数据库与其他数据库下的`database`是同一级别的，它本身无法创建`schema`，所有的表都存储于一个`schema`下，因此Access数据库中不存在跨库查询，也不需要获取数据库名
- Access数据库的所有表的内容全部都在网站源码中
- Access数据库没有文件读写的功能，因此高权限也没有什么意义

### 信息获取

- Access数据库的功能极其有限，不能获取操作系统、数据库用户和数据库版本(没有那些功能)
- 也不能获取数据库名，因此直接查询表、字段和数据即可

### 表和字段查询

- 只能使用暴力和猜测的方式来获取
- 如果表名和字段名暴力和猜测不到，

## MSSQL

直接百度查询注入即可，慢慢的逐步添加内容

## MySQL

MySQL 5.0之后的数据库、表和字段信息都存储在information_schema数据库中；而之前只能使用暴力查询或联合读取查询

|    表    | 字段                                  | 描述                                           |
| :------: | :------------------------------------ | ---------------------------------------------- |
| schemata | schema_name                           | 对应用户创建的数据库的库名                     |
|  tables  | table_schema、table_name              | 对应用户创建的数据库的库名和其中的表名         |
| columns  | table_schema、table_name、column_name | 对应用户创建的数据库的库名和其中的表名、字段名 |

### 常用函数

- 查询信息函数
  - database() - 当前所在数据库
  - version() - 当前数据库版本
  - user() - 当前登录用户
  - @@basedir - 当前安装路径
  - @@version_compile_os - 当前操作系统
- 字符串函数
  - substrs()和substring()
  - group_concat() - 将指定列的所有符合数据合并成一个字符串
  - mid()
  - left()
- 编码函数
  - ascii()
  - hex()
  - char() - ascii()的逆函数
- 文件函数
  - load_file() - 读取文件，一定要写绝对路径

# 绕过技术

- 大小写绕过